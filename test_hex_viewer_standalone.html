<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CREATOR Hex Viewer Test</title>
    <style>
      /* VSCode theme variables for standalone testing */
      :root {
        --vscode-editor-background: #1e1e1e;
        --vscode-editor-foreground: #d4d4d4;
        --vscode-panel-background: #252526;
        --vscode-panel-border: #464647;
        --vscode-input-background: #3c3c3c;
        --vscode-input-foreground: #cccccc;
        --vscode-input-border: #464647;
        --vscode-focusBorder: #007acc;
        --vscode-dropdown-background: #3c3c3c;
        --vscode-dropdown-foreground: #cccccc;
        --vscode-dropdown-border: #464647;
        --vscode-button-background: #0e639c;
        --vscode-button-foreground: #ffffff;
        --vscode-button-hoverBackground: #1177bb;
        --vscode-editorGroupHeader-tabsBackground: #2d2d30;
        --vscode-tab-activeForeground: #ffffff;
        --vscode-descriptionForeground: #969696;
        --vscode-list-hoverBackground: #2a2d2e;
        --vscode-list-hoverForeground: #cccccc;
        --vscode-list-activeSelectionBackground: #094771;
        --vscode-list-activeSelectionForeground: #ffffff;
        --vscode-disabledForeground: #616161;
        --vscode-statusBar-background: #007acc;
        --vscode-statusBar-foreground: #ffffff;
        --vscode-debugTokenExpression-number: #b5cea8;
        --vscode-debugTokenExpression-string: #ce9178;
        --vscode-debugTokenExpression-name: #9cdcfe;
        --vscode-editorHoverWidget-background: #252526;
        --vscode-editorHoverWidget-foreground: #cccccc;
        --vscode-editorHoverWidget-border: #454545;
        --vscode-symbolIcon-variableForeground: #75beff;
        --vscode-font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica,
          Arial, sans-serif;
      }

      body {
        margin: 0;
        padding: 0;
        background-color: var(--vscode-editor-background);
        color: var(--vscode-editor-foreground);
        font-family: var(--vscode-font-family);
      }

      #hex-viewer-container {
        width: 100%;
        height: 100vh;
      }
    </style>
    <style>
      .hex-viewer,
      .hex-viewer-content,
      .hex-viewer-body {
        height: 100%;
        min-height: 0;
        box-sizing: border-box;
      }
      .hex-byte.zero {
        opacity: 1 !important;
      }
    </style>
    <link rel="stylesheet" href="./vscode-extension/src/hexViewer.css" />
  </head>
  <body>
    <div id="hex-viewer-container"></div>

    <script>
      // HexViewer class implementation
      class HexViewer {
        constructor(container, options = {}) {
          this.container = container;
          this.memoryDump = null;
          this.bytesPerRow = options.bytesPerRow || 16;
          this.showAscii = options.showAscii !== false;
          this.showAddresses = options.showAddresses !== false;
          this.selectedByte = -1;
          this.hintMap = new Map();
          this.hintTooltip = null;
          this.onRefresh = null;

          this.setupContainer();
          this.setupEventListeners();
        }

        setupContainer() {
          this.container.innerHTML = `
                    <div class="hex-viewer">
                        <div class="hex-viewer-toolbar">
                            <div class="toolbar-group">
                                <button id="refresh-button" class="toolbar-button">Refresh Memory</button>
                            </div>
                            <div class="toolbar-group">
                                <label for="goto-address">Go to address:</label>
                                <input id="goto-address" class="address-input" type="text" placeholder="e.g. 0x200000" style="width:110px;">
                                <button id="goto-button" class="toolbar-button">Go</button>
                            </div>
                            <div class="toolbar-group">
                                <label for="bytes-per-row">Bytes/Row:</label>
                                <select id="bytes-per-row" class="bytes-per-row-select">
                                    <option value="8">8</option>
                                    <option value="16" selected>16</option>
                                    <option value="32">32</option>
                                    <option value="64">64</option>
                                </select>
                            </div>
                        </div>
                        <div class="hex-viewer-content">
                            <div class="hex-viewer-header">
                                <div class="address-column-header">Address</div>
                                <div class="hex-columns-header"></div>
                                ${this.showAscii ? '<div class="ascii-column-header">ASCII</div>' : ""}
                            </div>
                            <div class="hex-viewer-body" tabindex="0" style="overflow-y: auto; height: 100%;">
                                <div class="hex-rows"></div>
                            </div>
                        </div>
                        <div class="hex-viewer-status">
                            <span class="status-info">Ready</span>
                            <span class="selection-info"></span>
                        </div>
                    </div>
                `;

          this.updateHeader();
        }

        setupEventListeners() {
          const refreshButton = this.container.querySelector("#refresh-button");
          const gotoInput = this.container.querySelector("#goto-address");
          const gotoButton = this.container.querySelector("#goto-button");
          const bytesPerRowSelect =
            this.container.querySelector("#bytes-per-row");
          const hexViewerBody =
            this.container.querySelector(".hex-viewer-body");

          refreshButton.addEventListener("click", () => {
            if (this.onRefresh) {
              this.onRefresh();
            }
          });

          gotoButton.addEventListener("click", () => {
            this.handleGotoAddress(gotoInput.value);
          });
          gotoInput.addEventListener("keydown", e => {
            if (e.key === "Enter") {
              this.handleGotoAddress(gotoInput.value);
            }
          });

          bytesPerRowSelect.addEventListener("change", () => {
            this.bytesPerRow = parseInt(bytesPerRowSelect.value);
            this.updateHeader();
            this.render();
          });

          hexViewerBody.addEventListener("keydown", e => {
            this.handleKeyDown(e);
          });

          hexViewerBody.addEventListener("click", e => {
            this.handleClick(e);
          });

          hexViewerBody.addEventListener("mouseover", e => {
            this.handleMouseOver(e);
          });

          hexViewerBody.addEventListener("mouseout", e => {
            this.handleMouseOut(e);
          });

          // Handle window resize
          if (window.ResizeObserver) {
            const resizeObserver = new ResizeObserver(() => {
              this.adjustLayout();
            });
            resizeObserver.observe(this.container);
          }
        }

        handleGotoAddress(addrStr) {
          let address = 0;
          if (typeof addrStr !== "string" || addrStr.trim() === "") return;
          if (addrStr.startsWith("0x") || addrStr.startsWith("0X")) {
            address = parseInt(addrStr, 16);
          } else {
            address = parseInt(addrStr, 10);
          }
          if (isNaN(address) || !this.memoryDump) return;

          // Clamp to valid range
          address = Math.max(
            0,
            Math.min(address, this.memoryDump.highestAddress),
          );
          this.selectByte(address);

          // Scroll to row
          const row = Math.floor(address / this.bytesPerRow);
          const rowHeight = 24;
          const hexViewerBody =
            this.container.querySelector(".hex-viewer-body");
          hexViewerBody.scrollTop = row * rowHeight;
        }

        updateHeader() {
          const hexColumnsHeader = this.container.querySelector(
            ".hex-columns-header",
          );
          let headerHtml = "";

          for (let i = 0; i < this.bytesPerRow; i++) {
            headerHtml += `<span class="hex-column-header">${i.toString(16).toUpperCase().padStart(2, "0")}</span>`;
          }

          hexColumnsHeader.innerHTML = headerHtml;
        }

        handleKeyDown(e) {
          if (!this.memoryDump || this.memoryDump.highestAddress === 0) return;

          const maxIndex = this.memoryDump.highestAddress;
          let newSelection = this.selectedByte;

          switch (e.key) {
            case "ArrowLeft":
              newSelection = Math.max(0, this.selectedByte - 1);
              break;
            case "ArrowRight":
              newSelection = Math.min(maxIndex, this.selectedByte + 1);
              break;
            case "ArrowUp":
              newSelection = Math.max(0, this.selectedByte - this.bytesPerRow);
              break;
            case "ArrowDown":
              newSelection = Math.min(
                maxIndex,
                this.selectedByte + this.bytesPerRow,
              );
              break;
            case "Home":
              newSelection =
                Math.floor(this.selectedByte / this.bytesPerRow) *
                this.bytesPerRow;
              break;
            case "End":
              newSelection = Math.min(
                maxIndex,
                Math.floor(this.selectedByte / this.bytesPerRow) *
                  this.bytesPerRow +
                  this.bytesPerRow -
                  1,
              );
              break;
            case "PageUp":
              newSelection = Math.max(
                0,
                this.selectedByte - this.bytesPerRow * 10,
              );
              break;
            case "PageDown":
              newSelection = Math.min(
                maxIndex,
                this.selectedByte + this.bytesPerRow * 10,
              );
              break;
            default:
              return;
          }

          e.preventDefault();
          this.selectByte(newSelection);
        }

        handleClick(e) {
          const target = e.target;

          if (target.classList.contains("hex-byte")) {
            const index = parseInt(target.dataset.index || "-1");
            if (index >= 0) {
              this.selectByte(index);

              // Show hint tooltip on click
              const hintInfo = this.hintMap.get(index);
              if (hintInfo) {
                this.showHintTooltip(target, hintInfo);
              }
            }
          }
        }

        handleMouseOver(e) {
          const target = e.target;

          if (target.classList.contains("hex-byte")) {
            const index = parseInt(target.dataset.index || "-1");
            const hintInfo = this.hintMap.get(index);
            if (hintInfo) {
              this.showHintTooltip(target, hintInfo);
            }
          }
        }

        handleMouseOut(e) {
          const target = e.target;

          if (target.classList.contains("hex-byte")) {
            this.hideHintTooltip();
          }
        }

        showHintTooltip(element, hintInfo) {
          this.hideHintTooltip();

          const tooltip = document.createElement("div");
          tooltip.className = "hint-tooltip";

          const header = document.createElement("div");
          header.className = "hint-header";
          header.textContent = hintInfo.hint;
          tooltip.appendChild(header);

          if (hintInfo.sizeInBits) {
            const details = document.createElement("div");
            details.className = "hint-details";
            details.textContent = `Size: ${hintInfo.sizeInBits} bits (${Math.ceil(hintInfo.sizeInBits / 8)} bytes)`;
            tooltip.appendChild(details);
          }

          document.body.appendChild(tooltip);
          this.hintTooltip = tooltip;

          // Position the tooltip
          const rect = element.getBoundingClientRect();
          tooltip.style.left = `${rect.left}px`;
          tooltip.style.top = `${rect.bottom + 5}px`;

          // Adjust position if tooltip goes off screen
          const tooltipRect = tooltip.getBoundingClientRect();
          if (tooltipRect.right > window.innerWidth) {
            tooltip.style.left = `${window.innerWidth - tooltipRect.width - 10}px`;
          }
          if (tooltipRect.bottom > window.innerHeight) {
            tooltip.style.top = `${rect.top - tooltipRect.height - 5}px`;
          }
        }

        hideHintTooltip() {
          if (this.hintTooltip) {
            this.hintTooltip.remove();
            this.hintTooltip = null;
          }
        }

        selectByte(index) {
          if (
            !this.memoryDump ||
            index < 0 ||
            index > this.memoryDump.highestAddress
          )
            return;

          // Remove previous selection
          const prevSelected =
            this.container.querySelector(".hex-byte.selected");
          if (prevSelected) {
            prevSelected.classList.remove("selected");
          }

          const prevSelectedAscii = this.container.querySelector(
            ".ascii-char.selected",
          );
          if (prevSelectedAscii) {
            prevSelectedAscii.classList.remove("selected");
          }

          this.selectedByte = index;
          const hexByte = this.container.querySelector(
            `[data-index="${index}"].hex-byte`,
          );
          const asciiChar = this.container.querySelector(
            `[data-index="${index}"].ascii-char`,
          );

          if (hexByte) {
            hexByte.classList.add("selected");
            hexByte.scrollIntoView({ block: "nearest" });
          }

          if (asciiChar) {
            asciiChar.classList.add("selected");
          }

          this.updateSelectionInfo();
        }

        updateSelectionInfo() {
          const selectionInfo = this.container.querySelector(".selection-info");

          if (this.selectedByte >= 0 && this.memoryDump) {
            const address = this.selectedByte;
            const value = this.getMemoryValue(address);
            const char =
              value >= 32 && value <= 126 ? String.fromCharCode(value) : ".";

            let info = `Address: 0x${address.toString(16).toUpperCase().padStart(8, "0")} | Value: 0x${value.toString(16).toUpperCase().padStart(2, "0")} (${value}) | ASCII: '${char}'`;

            const hintInfo = this.hintMap.get(address);
            if (hintInfo) {
              info += ` | Hint: ${hintInfo.hint}`;
            }

            selectionInfo.textContent = info;
          } else {
            selectionInfo.textContent = "";
          }
        }

        adjustLayout() {
          const containerWidth = this.container.clientWidth;
          const minBytesPerRow = 8;

          // Estimate character widths
          const charWidth = 10;
          const addressWidth = 100;
          const asciiWidth = this.showAscii ? this.bytesPerRow * charWidth : 0;
          const hexWidth = this.bytesPerRow * 3 * charWidth;

          const totalNeededWidth = addressWidth + hexWidth + asciiWidth + 100; // padding

          if (
            totalNeededWidth > containerWidth &&
            this.bytesPerRow > minBytesPerRow
          ) {
            const newBytesPerRow = Math.max(
              minBytesPerRow,
              Math.floor(this.bytesPerRow / 2),
            );
            if (newBytesPerRow !== this.bytesPerRow) {
              this.bytesPerRow = newBytesPerRow;
              const select = this.container.querySelector("#bytes-per-row");
              select.value = this.bytesPerRow.toString();
              this.updateHeader();
              this.render();
            }
          }
        }

        getMemoryValue(address) {
          if (!this.memoryDump) return 0;

          const index = this.memoryDump.addresses.indexOf(address);
          if (index !== -1) {
            return this.memoryDump.values[index];
          }
          return 0; // Return 0 for unwritten memory
        }

        setMemoryDump(dump) {
          this.memoryDump = dump;
          this.selectedByte = -1;

          // Build hint map
          this.hintMap.clear();
          const hintColors = new Map();
          let colorIndex = 0;

          for (const hint of dump.hints) {
            const address = parseInt(hint.address);

            // Assign a color index to each unique hint type
            if (!hintColors.has(hint.hint)) {
              hintColors.set(hint.hint, colorIndex % 8);
              colorIndex++;
            }

            const hintColorIndex = hintColors.get(hint.hint);

            // Apply hint to all bytes covered by this hint
            const sizeInBytes = hint.sizeInBits
              ? Math.ceil(hint.sizeInBits / 8)
              : 1;
            for (let i = 0; i < sizeInBytes; i++) {
              this.hintMap.set(address + i, {
                hint: hint.hint,
                sizeInBits: hint.sizeInBits,
                colorIndex: hintColorIndex,
              });
            }
          }

          this.render();
          this.updateStatus();

          // Attach scroll event for virtual rendering
          const hexViewerBody =
            this.container.querySelector(".hex-viewer-body");
          if (hexViewerBody && !hexViewerBody._virtualScrollAttached) {
            hexViewerBody.addEventListener("scroll", () =>
              this.renderVisibleRows(),
            );
            hexViewerBody._virtualScrollAttached = true;
          }
        }

        render() {
          // Only called on initial setup or when memory dump/bytesPerRow changes
          const hexRows = this.container.querySelector(".hex-rows");
          hexRows.innerHTML = "";

          if (!this.memoryDump || this.memoryDump.highestAddress === 0) {
            hexRows.innerHTML = '<div class="no-data">No data in memory</div>';
            return;
          }

          // Set total height for scroll
          const hexViewerBody =
            this.container.querySelector(".hex-viewer-body");
          const rowHeight = 24; // px, adjust if needed
          const totalRows = Math.ceil(
            (this.memoryDump.highestAddress + 1) / this.bytesPerRow,
          );
          hexRows.style.position = "relative";
          hexRows.style.height = totalRows * rowHeight + "px";

          this.renderVisibleRows();
        }

        renderVisibleRows() {
          // Only rerender if scroll is near the edge of the buffer
          if (!this._renderState) this._renderState = {};
          const state = this._renderState;
          const hexRows = this.container.querySelector(".hex-rows");
          if (!this.memoryDump || this.memoryDump.highestAddress === 0) {
            return;
          }
          const hexViewerBody =
            this.container.querySelector(".hex-viewer-body");
          const rowHeight = 24;
          const totalRows = Math.ceil(
            (this.memoryDump.highestAddress + 1) / this.bytesPerRow,
          );

          // Calculate visible rows and buffer
          const scrollTop = hexViewerBody.scrollTop;
          const bodyHeight = hexViewerBody.clientHeight;
          const viewportRows = Math.ceil(bodyHeight / rowHeight);
          const bufferRows = viewportRows * 3; // buffer = 3x viewport
          const centerRow = Math.floor(scrollTop / rowHeight);
          const firstRow = Math.max(0, centerRow - bufferRows);
          const lastRow = Math.min(
            totalRows,
            centerRow + viewportRows + bufferRows,
          );

          // Only rerender if visible rows are outside the current rendered range or buffer is uninitialized
          const visibleStart = Math.floor(scrollTop / rowHeight);
          const visibleEnd = Math.min(totalRows, visibleStart + viewportRows);

          if (
            state.firstRow !== undefined &&
            state.lastRow !== undefined &&
            visibleStart >= state.firstRow &&
            visibleEnd <= state.lastRow
          ) {
            // Still within buffer, no need to rerender
            return;
          }
          state.firstRow = firstRow;
          state.lastRow = lastRow;

          Array.from(hexRows.children).forEach(e => hexRows.removeChild(e));

          // Spacer for top
          const topSpacer = document.createElement("div");
          topSpacer.className = "spacer";
          topSpacer.style.height = firstRow * rowHeight + "px";
          hexRows.appendChild(topSpacer);

          for (let row = firstRow; row < lastRow; row++) {
            const rowElement = document.createElement("div");
            rowElement.className = "hex-row";
            rowElement.style.height = rowHeight + "px";

            const startIndex = row * this.bytesPerRow;
            const endIndex = Math.min(
              startIndex + this.bytesPerRow,
              this.memoryDump.highestAddress + 1,
            );
            const address = startIndex;

            // Address column
            const addressElement = document.createElement("div");
            addressElement.className = "address-column";
            addressElement.textContent = `0x${address.toString(16).toUpperCase().padStart(8, "0")}`;
            rowElement.appendChild(addressElement);

            // Hex columns
            const hexColumnsElement = document.createElement("div");
            hexColumnsElement.className = "hex-columns";

            for (let i = 0; i < this.bytesPerRow; i++) {
              const byteIndex = startIndex + i;
              const hexByteElement = document.createElement("span");
              hexByteElement.className = "hex-byte";
              hexByteElement.dataset.index = byteIndex.toString();

              if (byteIndex <= this.memoryDump.highestAddress) {
                const value = this.getMemoryValue(byteIndex);
                hexByteElement.textContent = value
                  .toString(16)
                  .toUpperCase()
                  .padStart(2, "0");

                // Add zero class for dimming
                if (value === 0) {
                  hexByteElement.classList.add("zero");
                }

                // Add hint color class
                const hintInfo = this.hintMap.get(byteIndex);
                if (hintInfo) {
                  hexByteElement.classList.add(`hint-${hintInfo.colorIndex}`);
                }

                hexByteElement.title = `Address: 0x${byteIndex.toString(16).toUpperCase()}\nValue: 0x${value.toString(16).toUpperCase()} (${value})`;
              } else {
                hexByteElement.textContent = "  ";
                hexByteElement.classList.add("empty");
              }

              hexColumnsElement.appendChild(hexByteElement);
            }
            rowElement.appendChild(hexColumnsElement);

            // ASCII column
            if (this.showAscii) {
              const asciiElement = document.createElement("div");
              asciiElement.className = "ascii-column";

              for (let i = 0; i < this.bytesPerRow; i++) {
                const byteIndex = startIndex + i;
                const asciiCharElement = document.createElement("span");
                asciiCharElement.className = "ascii-char";
                asciiCharElement.dataset.index = byteIndex.toString();

                if (byteIndex <= this.memoryDump.highestAddress) {
                  const value = this.getMemoryValue(byteIndex);
                  const char =
                    value >= 32 && value <= 126
                      ? String.fromCharCode(value)
                      : ".";
                  asciiCharElement.textContent = char;

                  // Add hint color class
                  const hintInfo = this.hintMap.get(byteIndex);
                  if (hintInfo) {
                    asciiCharElement.classList.add(
                      `hint-${hintInfo.colorIndex}`,
                    );
                  }
                } else {
                  asciiCharElement.textContent = " ";
                  asciiCharElement.classList.add("empty");
                }

                asciiElement.appendChild(asciiCharElement);
              }
              rowElement.appendChild(asciiElement);
            }

            hexRows.appendChild(rowElement);
          }

          // Spacer for bottom
          const bottomSpacer = document.createElement("div");
          bottomSpacer.className = "spacer";
          bottomSpacer.style.height = (totalRows - lastRow) * rowHeight + "px";
          hexRows.appendChild(bottomSpacer);
        }

        setRefreshCallback(callback) {
          this.onRefresh = callback;
        }

        render() {
          const hexRows = this.container.querySelector(".hex-rows");
          hexRows.innerHTML = "";

          if (!this.memoryDump || this.memoryDump.highestAddress === 0) {
            hexRows.innerHTML = '<div class="no-data">No data in memory</div>';
            return;
          }

          // Virtual scrolling parameters
          const hexViewerBody =
            this.container.querySelector(".hex-viewer-body");
          const rowHeight = 24; // px, adjust if needed
          const totalRows = Math.ceil(
            (this.memoryDump.highestAddress + 1) / this.bytesPerRow,
          );

          // Calculate visible rows
          const scrollTop = hexViewerBody.scrollTop;
          const bodyHeight = hexViewerBody.clientHeight;
          const visibleRows = Math.ceil(bodyHeight / rowHeight) + 2;
          const firstRow = Math.max(0, Math.floor(scrollTop / rowHeight) - 1);
          const lastRow = Math.min(totalRows, firstRow + visibleRows);

          // Spacer for top
          const topSpacer = document.createElement("div");
          topSpacer.style.height = firstRow * rowHeight + "px";
          hexRows.appendChild(topSpacer);

          for (let row = firstRow; row < lastRow; row++) {
            const rowElement = document.createElement("div");
            rowElement.className = "hex-row";
            rowElement.style.height = rowHeight + "px";

            const startIndex = row * this.bytesPerRow;
            const endIndex = Math.min(
              startIndex + this.bytesPerRow,
              this.memoryDump.highestAddress + 1,
            );
            const address = startIndex;

            // Address column
            const addressElement = document.createElement("div");
            addressElement.className = "address-column";
            addressElement.textContent = `0x${address.toString(16).toUpperCase().padStart(8, "0")}`;
            rowElement.appendChild(addressElement);

            // Hex columns
            const hexColumnsElement = document.createElement("div");
            hexColumnsElement.className = "hex-columns";

            for (let i = 0; i < this.bytesPerRow; i++) {
              const byteIndex = startIndex + i;
              const hexByteElement = document.createElement("span");
              hexByteElement.className = "hex-byte";
              hexByteElement.dataset.index = byteIndex.toString();

              if (byteIndex <= this.memoryDump.highestAddress) {
                const value = this.getMemoryValue(byteIndex);
                hexByteElement.textContent = value
                  .toString(16)
                  .toUpperCase()
                  .padStart(2, "0");

                // Add zero class for dimming
                if (value === 0) {
                  hexByteElement.classList.add("zero");
                }

                // Add hint color class
                const hintInfo = this.hintMap.get(byteIndex);
                if (hintInfo) {
                  hexByteElement.classList.add(`hint-${hintInfo.colorIndex}`);
                }

                hexByteElement.title = `Address: 0x${byteIndex.toString(16).toUpperCase()}\nValue: 0x${value.toString(16).toUpperCase()} (${value})`;
              } else {
                hexByteElement.textContent = "  ";
                hexByteElement.classList.add("empty");
              }

              hexColumnsElement.appendChild(hexByteElement);
            }
            rowElement.appendChild(hexColumnsElement);

            // ASCII column
            if (this.showAscii) {
              const asciiElement = document.createElement("div");
              asciiElement.className = "ascii-column";

              for (let i = 0; i < this.bytesPerRow; i++) {
                const byteIndex = startIndex + i;
                const asciiCharElement = document.createElement("span");
                asciiCharElement.className = "ascii-char";
                asciiCharElement.dataset.index = byteIndex.toString();

                if (byteIndex <= this.memoryDump.highestAddress) {
                  const value = this.getMemoryValue(byteIndex);
                  const char =
                    value >= 32 && value <= 126
                      ? String.fromCharCode(value)
                      : ".";
                  asciiCharElement.textContent = char;

                  // Add hint color class
                  const hintInfo = this.hintMap.get(byteIndex);
                  if (hintInfo) {
                    asciiCharElement.classList.add(
                      `hint-${hintInfo.colorIndex}`,
                    );
                  }
                } else {
                  asciiCharElement.textContent = " ";
                  asciiCharElement.classList.add("empty");
                }

                asciiElement.appendChild(asciiCharElement);
              }
              rowElement.appendChild(asciiElement);
            }

            hexRows.appendChild(rowElement);
          }

          // Spacer for bottom
          const bottomSpacer = document.createElement("div");
          bottomSpacer.style.height = (totalRows - lastRow) * rowHeight + "px";
          hexRows.appendChild(bottomSpacer);
        }

        updateStatus() {
          const statusInfo = this.container.querySelector(".status-info");

          if (this.memoryDump) {
            const writtenCount = this.memoryDump.addresses.length;
            const highestAddr = this.memoryDump.highestAddress;
            statusInfo.textContent = `Showing memory up to 0x${highestAddr.toString(16).toUpperCase()} (${writtenCount} bytes written)`;
          } else {
            statusInfo.textContent = "No memory data loaded";
          }
        }

        focus() {
          const hexViewerBody =
            this.container.querySelector(".hex-viewer-body");
          hexViewerBody.focus();
        }
      }

      // Initialize the hex viewer with test data
      document.addEventListener("DOMContentLoaded", () => {
        const container = document.getElementById("hex-viewer-container");
        const hexViewer = new HexViewer(container);

        // Simulate memory dump data from our test
        const mockMemoryDump = {
          addresses: [
            // Code section
            0x00000000, 0x00000001, 0x00000002, 0x00000003, 0x00000004,
            0x00000005, 0x00000006, 0x00000007, 0x00000008, 0x00000009,
            0x0000000a, 0x0000000b,
            // Data section with our test data
            0x00200000, 0x00200001, 0x00200002, 0x00200003, 0x00200004,
            0x00200005, 0x00200006, 0x00200007, 0x00200008, 0x00200009,
            0x0020000a, 0x0020000b, 0x0020000c, 0x0020000d, 0x0020000e,
            0x0020000f, 0x00200010, 0x00200011, 0x00200012, 0x00200013,
            0x00200014, 0x00200015, 0x00200016, 0x00200017, 0x00200018,
            0x00200019, 0x0020001a, 0x0020001b, 0x0020001c, 0x0020001d,
            0x0020001e, 0x0020001f, 0x00200020, 0x00200021, 0x00200022,
            0x00200023, 0x00200024, 0x00200025, 0x00200026, 0x00200027,
          ],
          values: [
            // Code section
            0x00, 0x20, 0x05, 0x17, 0x00, 0x05, 0x05, 0x13, 0x00, 0x20, 0x03,
            0x37,
            // Data section - "Hello, World!" string
            0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x6f, 0x72, 0x6c,
            0x64, 0x21, 0x00, 0x00, 0x00,
            // nums array
            0x78, 0x56, 0x34, 0x12, 0xf0, 0xde, 0xbc, 0x9a, 0xef, 0xbe, 0xad,
            0xde, 0xbe, 0xba, 0xfe, 0xca,
            // bytes array
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
          ],
          hints: [
            { address: "2097152", hint: "msg: <string>", sizeInBits: 104 },
            { address: "2097166", hint: "<padding>", sizeInBits: 16 },
            { address: "2097168", hint: "nums: <word>", sizeInBits: 32 },
            { address: "2097172", hint: "<word>", sizeInBits: 32 },
            { address: "2097176", hint: "<word>", sizeInBits: 32 },
            { address: "2097180", hint: "<word>", sizeInBits: 32 },
            { address: "2097184", hint: "bytes: <byte>", sizeInBits: 8 },
            { address: "2097185", hint: "<byte>", sizeInBits: 8 },
            { address: "2097186", hint: "<byte>", sizeInBits: 8 },
            { address: "2097187", hint: "<byte>", sizeInBits: 8 },
            { address: "2097188", hint: "<byte>", sizeInBits: 8 },
            { address: "2097189", hint: "<byte>", sizeInBits: 8 },
            { address: "2097190", hint: "<byte>", sizeInBits: 8 },
            { address: "2097191", hint: "<byte>", sizeInBits: 8 },
          ],
          wordSize: 4,
          highestAddress: 0x00200027,
        };

        // Set up refresh callback
        hexViewer.setRefreshCallback(() => {
          console.log("Refresh button clicked");
          // In a real scenario, this would fetch new memory data
        });

        // Load the memory dump
        hexViewer.setMemoryDump(mockMemoryDump);

        // Focus the hex viewer for keyboard navigation
        hexViewer.focus();

        console.log("Hex viewer initialized with test data");
        console.log("Try:");
        console.log("- Using arrow keys to navigate");
        console.log("- Clicking on bytes to select them");
        console.log("- Hovering over colored bytes to see hints");
        console.log("- Changing bytes per row in the dropdown");
      });
    </script>
  </body>
</html>
